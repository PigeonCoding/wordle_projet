
Report
Topic : Wordle solver
Tool : C language

I . Strategy Description 
 A . the strategy : using word from a dictionair who contains 
Max_Word : 6969
Word_length :6   
thefirst guess is fixed ("brain") becaus it contains common letters and distinct characters the solver selects the word that minimizes the expected 
remaining candidate space and at the end choosing the guess with the lowest entropy score

B . The feedback strategy :  the solver check letter by letter until the end of word by (target[i] and all[i]) it stored in all[i]
If the letter of guess = to word of user then we say “GOOD”:
if (guess_copy[i] == target[i]) {
      all[i].letter = guess[i];
      all[i].state = GOOD;
}
And if the letter is exist and not in position i we say “exist”:
 else if (strchr(target, guess_copy[i])) {
      all[i].letter = guess[i];
      all[i].state = EXISTS;
} 

Else if is it false we say “NUH” :
else {
      all[i].letter = guess[i];
      all[i].state = NUH;
    }
 
C . The approach is effective : 
because it simple and not take as much of complexity and it suits the problem
.the feedback ensure correctness even when we have repeated letters
..It systematically reduces uncertainty instead of guessing randomly
...fast convergence to the get the word usualy within fewer than 6 attempts

II Data stucture :
1.The data structure : in our wordle project we mainly used arrays , including array for managing the word , game state and storing words
words[MAX_WORDS][WORD_LENGTH]
pool[MAX_WORDS][WORD_LENGTH]
These store the dictionary and remaining candidates efficiently with fixed-size memory

2.struct attempt_response
typedef struct {
  char letter;
  int state;
} attempt_response;
and these to represent the feedback

3.Global Feedback Array
attempt_response all[5];

4.Integer Arrays
int counts[243];
the solver has using a methode pattern_code , this mathode make a theory for all words of the dictionary by make a codification of all of them using a loop


 for (int i = 0; i < 5; i++) {
        c = c * 3 + fb[i].state;
}
This loop check state of all leters for 1 to 6 and multiply it by 3 to get result c 
We check the result in every attempts and then we multiply by I to get the final score 
 int score = 0;
    for (int i = 0; i < 243; i++) {
        if (counts[i] > 0) {
            score += counts[i] * counts[i];
        }
    }

    return score;
}
We check the all the patterns and we chose the one who gets more variety and check the score  
and choose the less score , the less score we get the more the solver go to find the word guess  
Until the attempts end  .

the alternative d.s : 
We consider using a linked list to store the dictionary words its same complixity and we get same result 

D.Complexity analysis :
The code compares the guessed word with each word in the dictionary the word.length is constant so  
we have N = number of word , L = word length (5)

entropy_score: O(N × L²) per guess
best_entropy_guess: O(N² × L²) worst case

Space Complexity:
Dictionary storage: O(N × L)
Pool storage: O(N × L)

The space complexity of the system is linear o(n)

// Provide graphe :

D. Code documentation :
Solver Architecture :
init_wordle()
Initializes the dictionary and randomly selects the target word.

feedback()
Generates feedback for a guess while correctly handling repeated letters.
simulate_feedback()
Recreates Wordle logic for solver-side simulations, independent of the real target.

filter_pool()
Eliminates impossible words based on feedback consistency.

entropy_score()
Evaluates how well a guess partitions the remaining candidates.

best_entropy_guess()
Selects the guess with minimum entropy score

Commentes Code :
int entropy_score(const char *g) {
    int counts[243] = {0};
    attempt_response sim[5];

    // Simulate feedback for guess g against all candidates
    for (int i = 0; i < pool_count; i++) {
        simulate_feedback(g, pool[i], sim);
        int code = pattern_code(sim);
        counts[code]++;
    }

    // Lower score means better information gain
    int score = 0;
    for (int i = 0; i < 243; i++) {
        if (counts[i] > 0) {
            score += counts[i] * counts[i];
        }
    }

    return score;
}
 3 state of feedback then squared counts penalize that fail to split the pool evenly then minimizing score

